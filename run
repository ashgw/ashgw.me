
#!/usr/bin/env zsh
set -euo pipefail

# ====== CONFIG (edit if you need) ======
PKG="packages/rate-limiter"
NEW_REMOTE="git@github.com:ashgw/rate-limiter.git"
BRANCH="main"

# ====== helpers ======
log() { printf "\033[1;34m[INFO]\033[0m %s\n" "$*"; }
warn(){ printf "\033[1;33m[WARN]\033[0m %s\n" "$*"; }
err() { printf "\033[1;31m[ERR ]\033[0m %s\n" "$*"; }
die() { err "$*"; exit 1; }

require() { command -v "$1" >/dev/null 2>&1 || die "Missing command: $1"; }

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || true)"
[[ -n "$ROOT" ]] || die "Run from inside the monorepo"
cd "$ROOT"

require git

[[ -d "$PKG" ]] || die "Folder not found: $PKG"
git diff --quiet || die "Uncommitted changes in working tree"
git diff --cached --quiet || die "Staged but uncommitted changes"

# Unshallow if needed
if [[ "$(git rev-parse --is-shallow-repository)" == "true" ]]; then
  log "Unshallowing…"
  git fetch --unshallow --tags
else
  git fetch --all --tags
fi

# Backup tag
TAG="backup/pre-submodule-$(date +%Y%m%d-%H%M%S)"
log "Tagging backup: $TAG"
git tag "$TAG" || true
git push --tags || warn "Could not push tags (continuing)"

# Temp dir portable
TMPBASE="$(mktemp -d 2>/dev/null || mktemp -d -t rl-export)"
cleanup() { rm -rf "$TMPBASE" 2>/dev/null || true; }
trap cleanup EXIT

# ====== 1) EXPORT PKG TO NEW REPO ======
USE_FILTER_REPO=0
if git filter-repo -h >/dev/null 2>&1; then
  USE_FILTER_REPO=1
elif command -v git-filter-repo >/dev/null 2>&1; then
  USE_FILTER_REPO=1
fi

if [[ $USE_FILTER_REPO -eq 1 ]]; then
  log "Exporting with git filter-repo…"
  EXPORT_DIR="$TMPBASE/export"
  git clone --no-local . "$EXPORT_DIR"
  pushd "$EXPORT_DIR" >/dev/null
  git filter-repo --path "$PKG" --force
  git remote remove origin >/dev/null 2>&1 || true
  git remote add origin "$NEW_REMOTE"
  git branch -M "$BRANCH"
  log "Pushing extracted repo → $NEW_REMOTE ($BRANCH)…"
  git push -u origin "$BRANCH" --tags
  popd >/dev/null
else
  warn "git filter-repo not found. Using subtree + filter-branch (slower)…"
  SPLIT_BRANCH="split-$(basename "$PKG" | tr '/' '-')-$(date +%s)"
  git subtree split --prefix="$PKG" -b "$SPLIT_BRANCH"
  EXPORT_DIR="$TMPBASE/export"
  git init "$EXPORT_DIR"
  pushd "$EXPORT_DIR" >/dev/null
  git pull "$ROOT" "$SPLIT_BRANCH"
  git remote add origin "$NEW_REMOTE"
  git branch -M "$BRANCH"
  log "Pushing extracted repo → $NEW_REMOTE ($BRANCH)…"
  git push -u origin "$BRANCH" --tags
  popd >/dev/null
  git branch -D "$SPLIT_BRANCH" || true
fi

# ====== 2) PURGE FOLDER FROM MONOREPO HISTORY ======
if [[ $USE_FILTER_REPO -eq 1 ]]; then
  log "Purging '$PKG' from history with git filter-repo…"
  git filter-repo --path "$PKG" --invert-paths --force
else
  warn "Purging with filter-branch (this can take a while)…"
  git filter-branch --force --index-filter \
    "git rm -r --cached --ignore-unmatch '$PKG'" \
    --prune-empty --tag-name-filter cat -- --all
fi

# Ensure working tree is clean of remnants
if [[ -e "$PKG" ]]; then
  git rm -r --cached "$PKG" || true
  rm -rf "$PKG"
fi

log "Force-pushing rewritten history…"
git push --force --all
git push --force --tags || true

# ====== 3) ADD SUBMODULE ======
log "Adding submodule at '$PKG' → $NEW_REMOTE ($BRANCH)…"
mkdir -p "$(dirname "$PKG")"
git submodule add -b "$BRANCH" "$NEW_REMOTE" "$PKG" || {
  git submodule sync
  git submodule add -b "$BRANCH" "$NEW_REMOTE" "$PKG"
}

git commit -m "Use $(basename "$PKG") as a submodule" || true
git push || warn "Push failed; check remote permissions"

# ====== DONE ======
log "Done.

Next clone/update will need:
  git submodule update --init --recursive

Quick check:
  git ls-tree HEAD '$PKG'   # should show mode 160000 and a commit SHA
"

