
#!/usr/bin/env zsh
set -e
set -u
set -o pipefail

# ========= CONFIG =========
PKG="packages/rate-limiter"
SUBREMOTE="git@github.com:ashgw/limico.git"

# ========= helpers =========
log() { printf "\033[1;34m[INFO]\033[0m %s\n" "$*"; }
die() { printf "\033[1;31m[ERR ]\033[0m %s\n" "$*"; exit 1; }

# ========= sanity =========
command -v git >/dev/null 2>&1 || die "git not found"
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "run inside the repo root"
[[ -d "$PKG" ]] || die "folder not found: $PKG"

# require filter-repo (no slow fallbacks)
if ! git filter-repo -h >/dev/null 2>&1; then
  command -v git-filter-repo >/dev/null 2>&1 || die "install git-filter-repo (brew install git-filter-repo / pipx install git-filter-repo)"
fi

# clean tree
if [[ -n "$(git status --porcelain)" ]]; then
  die "working tree not clean; commit/stash first"
fi

# ensure full history
if [[ "$(git rev-parse --is-shallow-repository)" == "true" ]]; then
  log "Unshallowing…"
  git fetch --unshallow --tags
else
  git fetch --all --tags
fi

CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"

# ========= 1) PURGE from ALL history =========
log "Purging '$PKG' from history…"
git filter-repo --path "$PKG" --invert-paths --force

# hard cleanup of old refs and loose objects
git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin || true
git reflog expire --expire=now --all || true
git gc --prune=now --aggressive || true

# verify
if git rev-list --all -- "$PKG" | head -1 | grep -q .; then
  die "path still present in history (filter-repo failed?)"
fi

# ========= 2) FORCE-PUSH rewritten history =========
log "Force-pushing ALL branches…"
git push origin --force --all || die "force-push blocked (disable branch protection temporarily)"
log "Force-pushing tags…"
git push origin --force --tags || true

# remove any working copy leftovers
if [[ -e "$PKG" && ! -d "$PKG/.git" ]]; then
  git rm -r --cached "$PKG" >/dev/null 2>&1 || true
  rm -rf "$PKG"
  git commit -m "Remove $PKG after history purge" || true
  git push || true
fi

# clean previous submodule metadata if any
git submodule deinit -f "$PKG" >/dev/null 2>&1 || true
rm -rf ".git/modules/$PKG" >/dev/null 2>&1 || true

# ========= 3) ADD as SUBMODULE =========
log "Adding submodule '$SUBREMOTE' at '$PKG'…"
mkdir -p "$(dirname "$PKG")"

# try main, then master, else default HEAD
if git ls-remote --exit-code --heads "$SUBREMOTE" main >/dev/null 2>&1; then
  git submodule add -f -b main "$SUBREMOTE" "$PKG"
elif git ls-remote --exit-code --heads "$SUBREMOTE" master >/dev/null 2>&1; then
  git submodule add -f -b master "$SUBREMOTE" "$PKG"
else
  git submodule add -f "$SUBREMOTE" "$PKG"
fi

git commit -m "Add $PKG as submodule from $SUBREMOTE" || true
git push || die "push failed; check permissions"

# ========= 4) VERIFY =========
MODE="$(git ls-tree HEAD "$PKG" | awk '{print $1}')"
[[ "$MODE" == "160000" ]] || die "submodule not recorded as gitlink (mode=$MODE)"

log "Done. '$PKG' is a submodule now.
To init locally after clone:
  git submodule update --init --recursive
Current branch: $CURRENT_BRANCH
"

