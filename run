
#!/usr/bin/env bash
set -euo pipefail

ROOT="packages/error/src"
mkdir -p "$ROOT"

# codes.ts
cat > "$ROOT/codes.ts" <<'TS'
export const AppCodes = {
  BAD_REQUEST: "BAD_REQUEST",
  PARSE_ERROR: "PARSE_ERROR",
  INVALID_REQUEST: "INVALID_REQUEST",
  UNAUTHORIZED: "UNAUTHORIZED",
  FORBIDDEN: "FORBIDDEN",
  NOT_FOUND: "NOT_FOUND",
  METHOD_NOT_SUPPORTED: "METHOD_NOT_SUPPORTED",
  CONFLICT: "CONFLICT",
  PRECONDITION_FAILED: "PRECONDITION_FAILED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  UNPROCESSABLE_CONTENT: "UNPROCESSABLE_CONTENT",
  TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS",
  TIMEOUT: "TIMEOUT",
  CLIENT_CLOSED_REQUEST: "CLIENT_CLOSED_REQUEST",

  INTERNAL: "INTERNAL",
  NOT_IMPLEMENTED: "NOT_IMPLEMENTED",
  BAD_GATEWAY: "BAD_GATEWAY",
  SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
  GATEWAY_TIMEOUT: "GATEWAY_TIMEOUT",
} as const;

export type AppCode = keyof typeof AppCodes;

export interface AppHttpBody {
  readonly code: AppCode;
  readonly message: string;
  readonly meta?: Record<string, unknown>;
}
TS

# error.ts (fixed fromUnknown types)
cat > "$ROOT/error.ts" <<'TS'
import type { AppCode } from "./codes";

export interface AppErrorOptions {
  readonly code: AppCode;
  readonly message?: string;
  readonly cause?: unknown;
  readonly meta?: Readonly<Record<string, unknown>>;
  readonly exposeMessage?: boolean;
}

export class AppError extends Error {
  public readonly code: AppCode;
  public readonly cause?: unknown;
  public readonly meta?: Readonly<Record<string, unknown>>;
  public readonly exposeMessage: boolean;

  constructor(opts: AppErrorOptions) {
    // Keep compatibility with runtimes lacking ErrorOptions
    // @ts-expect-error optional second arg not in older lib dom
    super(opts.message ?? opts.code, { cause: opts.cause });
    this.name = "AppError";
    this.code = opts.code;
    this.cause = opts.cause;
    this.meta = opts.meta;
    this.exposeMessage = opts.exposeMessage ?? true;
    Object.setPrototypeOf(this, new.target.prototype);
  }

  public toJSON(): { name: "AppError"; code: AppCode; message: string; meta?: Record<string, unknown> } {
    return {
      name: "AppError",
      code: this.code,
      message: this.message,
      ...(this.meta ? { meta: { ...this.meta } } : {}),
    };
  }

  static fromUnknown(
    u: unknown,
    fallback: { code: AppCode; message?: string; meta?: Readonly<Record<string, unknown>> } = { code: "INTERNAL" },
  ): AppError {
    if (u instanceof AppError) return u;
    if (u instanceof Error) {
      return new AppError({
        code: fallback.code,
        message: u.message,
        cause: u,
        meta: fallback.meta,
        exposeMessage: false,
      });
    }
    return new AppError({
      code: fallback.code,
      message: String(u),
      cause: u,
      meta: fallback.meta,
      exposeMessage: false,
    });
  }
}
TS

# guards.ts (clean ensure signature)
cat > "$ROOT/guards.ts" <<'TS'
import { AppError } from "./error";
import type { AppCode } from "./codes";

export function isAppError(e: unknown): e is AppError {
  return e instanceof AppError && e.name === "AppError";
}

export function ensureAppError(e: unknown, code: AppCode = "INTERNAL"): AppError {
  return AppError.fromUnknown(e, { code });
}
TS

# http.ts
cat > "$ROOT/http.ts" <<'TS'
import type { AppCode, AppHttpBody } from "./codes";
import { AppError } from "./error";

export type HttpStatus =
  | 400 | 401 | 403 | 404 | 405 | 409 | 412 | 413 | 422 | 429
  | 408 | 499
  | 500 | 501 | 502 | 503 | 504;

const httpByCode: Record<AppCode, HttpStatus> = {
  BAD_REQUEST: 400,
  PARSE_ERROR: 400,
  INVALID_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_SUPPORTED: 405,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  TIMEOUT: 408,
  CLIENT_CLOSED_REQUEST: 499,

  INTERNAL: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
};

export function httpStatusFromCode(code: AppCode): HttpStatus {
  return httpByCode[code];
}

export function toHttp(e: AppError): { status: HttpStatus; body: AppHttpBody } {
  const status = httpStatusFromCode(e.code);
  const safeMessage = e.exposeMessage ? e.message : defaultMessage(e.code);
  const body: AppHttpBody = {
    code: e.code,
    message: safeMessage,
    ...(e.meta ? { meta: e.meta as Record<string, unknown> } : {}),
  };
  return { status, body };
}

export function toHttpFromUnknown(u: unknown): { status: HttpStatus; body: AppHttpBody } {
  const e = AppError.fromUnknown(u, { code: "INTERNAL" });
  return toHttp(e);
}

function defaultMessage(code: AppCode): string {
  switch (code) {
    case "BAD_REQUEST":
    case "PARSE_ERROR":
    case "INVALID_REQUEST":
      return "Bad request";
    case "UNAUTHORIZED":
      return "Unauthorized";
    case "FORBIDDEN":
      return "Forbidden";
    case "NOT_FOUND":
      return "Not found";
    case "METHOD_NOT_SUPPORTED":
      return "Method not supported";
    case "CONFLICT":
      return "Conflict";
    case "PRECONDITION_FAILED":
      return "Precondition failed";
    case "PAYLOAD_TOO_LARGE":
      return "Payload too large";
    case "UNPROCESSABLE_CONTENT":
      return "Unprocessable content";
    case "TOO_MANY_REQUESTS":
      return "Too many requests";
    case "TIMEOUT":
      return "Request timeout";
    case "CLIENT_CLOSED_REQUEST":
      return "Client closed request";
    case "NOT_IMPLEMENTED":
      return "Not implemented";
    case "BAD_GATEWAY":
      return "Bad gateway";
    case "SERVICE_UNAVAILABLE":
      return "Service unavailable";
    case "GATEWAY_TIMEOUT":
      return "Gateway timeout";
    case "INTERNAL":
    default:
      return "Internal error";
  }
}
TS

# trpc.ts
cat > "$ROOT/trpc.ts" <<'TS'
import type { AppCode } from "./codes";
import { AppError } from "./error";

export type TRPCErrorCtor<Code extends string> =
  new (opts: { code: Code; message?: string; cause?: unknown }) => unknown;

export type TrpcCode =
  | "PARSE_ERROR"
  | "BAD_REQUEST"
  | "INTERNAL_SERVER_ERROR"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "NOT_FOUND"
  | "METHOD_NOT_SUPPORTED"
  | "TIMEOUT"
  | "CONFLICT"
  | "PRECONDITION_FAILED"
  | "PAYLOAD_TOO_LARGE"
  | "UNPROCESSABLE_CONTENT"
  | "TOO_MANY_REQUESTS"
  | "CLIENT_CLOSED_REQUEST";

const trpcByCode: Record<AppCode, TrpcCode> = {
  BAD_REQUEST: "BAD_REQUEST",
  PARSE_ERROR: "PARSE_ERROR",
  INVALID_REQUEST: "BAD_REQUEST",
  UNAUTHORIZED: "UNAUTHORIZED",
  FORBIDDEN: "FORBIDDEN",
  NOT_FOUND: "NOT_FOUND",
  METHOD_NOT_SUPPORTED: "METHOD_NOT_SUPPORTED",
  CONFLICT: "CONFLICT",
  PRECONDITION_FAILED: "PRECONDITION_FAILED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  UNPROCESSABLE_CONTENT: "UNPROCESSABLE_CONTENT",
  TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS",
  TIMEOUT: "TIMEOUT",
  CLIENT_CLOSED_REQUEST: "CLIENT_CLOSED_REQUEST",

  INTERNAL: "INTERNAL_SERVER_ERROR",
  NOT_IMPLEMENTED: "INTERNAL_SERVER_ERROR",
  BAD_GATEWAY: "INTERNAL_SERVER_ERROR",
  SERVICE_UNAVAILABLE: "INTERNAL_SERVER_ERROR",
  GATEWAY_TIMEOUT: "TIMEOUT",
};

export function trpcCodeFromApp(code: AppCode): TrpcCode {
  return trpcByCode[code];
}

export function toTrpc<TCtor extends TRPCErrorCtor<TrpcCode>>(ctor: TCtor, e: AppError) {
  const code = trpcCodeFromApp(e.code);
  return new ctor({ code, message: e.message, cause: e });
}

export function toTrpcFromUnknown<TCtor extends TRPCErrorCtor<TrpcCode>>(ctor: TCtor, u: unknown) {
  const e = AppError.fromUnknown(u, { code: "INTERNAL" });
  return toTrpc(ctor, e);
}
TS

# factory.ts
cat > "$ROOT/factory.ts" <<'TS'
import { AppError } from "./error";
import type { AppCode } from "./codes";

type Meta = Readonly<Record<string, unknown>>;

function make(code: AppCode) {
  return (message?: string, meta?: Meta, cause?: unknown) =>
    new AppError({ code, message, meta, cause });
}

export const E = {
  badRequest: make("BAD_REQUEST"),
  parseError: make("PARSE_ERROR"),
  invalidRequest: make("INVALID_REQUEST"),
  unauthorized: make("UNAUTHORIZED"),
  forbidden: make("FORBIDDEN"),
  notFound: make("NOT_FOUND"),
  methodNotSupported: make("METHOD_NOT_SUPPORTED"),
  conflict: make("CONFLICT"),
  preconditionFailed: make("PRECONDITION_FAILED"),
  payloadTooLarge: make("PAYLOAD_TOO_LARGE"),
  unprocessableContent: make("UNPROCESSABLE_CONTENT"),
  tooManyRequests: make("TOO_MANY_REQUESTS"),
  timeout: make("TIMEOUT"),
  clientClosedRequest: make("CLIENT_CLOSED_REQUEST"),

  internal: make("INTERNAL"),
  notImplemented: make("NOT_IMPLEMENTED"),
  badGateway: make("BAD_GATEWAY"),
  serviceUnavailable: make("SERVICE_UNAVAILABLE"),
  gatewayTimeout: make("GATEWAY_TIMEOUT"),
} as const;
TS

# index.ts (export new adapters)
cat > "$ROOT/index.ts" <<'TS'
export { AppError } from "./error";
export type { AppErrorOptions } from "./error";
export { AppCodes } from "./codes";
export type { AppCode, AppHttpBody } from "./codes";
export { isAppError, ensureAppError } from "./guards";
export { httpStatusFromCode, toHttp, toHttpFromUnknown } from "./http";
export type { HttpStatus } from "./http";
export { trpcCodeFromApp, toTrpc, toTrpcFromUnknown } from "./trpc";
export { E } from "./factory";
TS

echo "OK: @ashgw/error files written."

